# Natural Permutations

A permutation is a mapping which reorders elements of a set. The set can be finite, or infinite. There are many "simple" permutations on infinite sets — for example, the identity permutation simply maps an element to itself (no reordering). This writeup takes up the challenge of defining a non-simple permutation on the natural numbers. The approach is to define an encoding as an invertible mapping from the natural numbers onto a subspace of _canonical binary strings_. The permutation is defined by composing one encoding $benc$ with the inverse of a completely different one $penc$. This writeup includes exposition, as well as some limited exploration and analysis.

# Finite Permutations

A permutation $\pi : X \rightarrow X$ is a 1-1 mapping from a set onto itself. In other words, it is an invertible mapping whose image covers the domain.

Every finite permutation can be modeled as a permutation on the integers modulo n, $\mathbb{Z}_n = \{ 0, 1, \ldots, n-1 \}$. Here is an example on $\mathbb{Z}_6$:

```math
\pi = 
    \begin{pmatrix}
        0 & \rightarrow & 0 \\
        1 & \rightarrow & 2 \\
        2 & \rightarrow & 4 \\
        3 & \rightarrow & 5 \\
        4 & \rightarrow & 1 \\
        5 & \rightarrow & 3 \\
    \end{pmatrix}
```

Note that $\pi(0) = 0$, in other words $\pi$ maps $0$ to itself. This means that $0$ is a **fixed point** of $\pi$.

The **orbit** of an element is the sequence of elements that is generated by applying the permutation repeatedly, so that the output of one application becomes the input for the next. Let us examine the orbit of $3$ under $\pi$:

```math
\pi: 3 \rightarrow 5 \rightarrow 3 \rightarrow 5 \rightarrow \ldots
```

$\pi$ maps $3$ to $5$, and $5$ back to $3$. When the orbit of an element returns to the original element, it is called a cycle. This cycle can be efficiently represented with the cycle notation $(35)$; it is called a 2-cycle because the orbit passes through 2 elements before it repeats. 

In fact, fixed points are a special case of cycles — they are 1-cycles. Besides the 1-cycle $(0)$ and the 2-cycle $(35)$, $\pi$ also has a 3-cycle, $(124)$. Note that the number of elements in the domain of $\pi$, $| \mathbb{Z}_6 | = 6$, is the sum of the lengths of the cycles of $\pi$. It turns out that every finite permutation can be uniquely represented as the product of its cycles, which form a partition over the domain. For example, the cycle notation for $\pi$ is $(0)(124)(36)$.

The reasons this writeup has gone into such detail on the integers modulo n are
1. every finite permutation is isomorphic to a permutation on $\mathbb{Z}_n$ for some $n$
2. the notions of orbit, cycle, and partition are relevant for permutations on infinite sets

# Common

## Sets

We will use the following, countably infinite sets throughout the remainder of this writeup:

| name                     | symbol           | values                              |
| :--                      | :--              | :--                                 |
| natural numbers          | $\mathbb{N}$     | $\{ 0, 1 ,2, \ldots \}$             |
| integers                 | $\mathbb{Z}$     | $\{ \ldots, -1, 0, 1, 2, \ldots \}$ |
| positive natural numbers | $\mathbb{Z}^{+}$ | $\{1,2,\ldots\}$                    |

## Mappings

We will abuse notation slightly by referring to the following mappings, without regard to their domains.

| shift-by-k      | $\sigma_k(n)$ | $n \rightarrow n + k$ |
| multiply-by-k   | $\mu_k(n)$    | $n \rightarrow k \cdot n |
| parity-flipping | $\rho(n)$     | $n \rightarrow n + 1$ if n is even, else $n - 1$ |
| sign-flipping   | $\phi(n)$     | $n \rightarrow -n$ |

## Invertibility

The requirement of invertibility imposes strong constraints on whether a mapping constitutes a permutation. 

For example, define the doubling function $\mu_2(n) = 2n$ on the integers. This mapping cannot define a permutation, because the image does not cover the entire set. For example, the value $3$ does not have an inverse. More generally, the multiply-by-k mapping $\mu_k(n) = kn$ cannot define a permutation on $\mathbb{Z}$ for any value of $k$ (except $|k| = 1$).

Mappings which are invertible on the integers might not be on the natural numbers. For example, let $\rho_1(n) = n + 1$ be the shift-by-one mapping. This is inveritble for the integers. However, if the domain is the natural numbers, $\rho_1$ does not define a permutation. This is because the natural numbers have a least element, $0$. There is no inverse for this element; the integer $-1$ could be the inverse, except $-1$ is not a natural number.

## Canonical Binary Strings

Let the binary alphabet be $ \Sigma = \{ 0,1 \} $. Further, let $\Sigma^{*}$ be the set of finite strings over this alphabet. A string $s \in \Sigma^*$ is in canonical form if any of the following conditions hold:
* $s = \langle 0 \rangle$
* the initial (most significant) bit of $s$ is a $1$

(Notation: We enclose strings with angle brackets, but not individual characters of the alphabet.) An example of a non-canonical string is $\langle 0101 \rangle$. It is non-canonical because the initial bit is $0$. The canonical binary string that corresponds to $\langle 0101 \rangle$ is $\langle 101 \rangle$. In general, a canonical binary string can be obtained from a non-canonical one by stripping all leading $0$'s. The sole exception is when the string contains no $1$'s; in that case, a single leading $0$ is allowed (to distinguish $\langle 0 \rangle$ from an empty string). Formally, we define canonical binary strings as the subset of $\Sigma^{*}$ which is in canonical form:

```math
\mathbb{B} = \{ \langle 0 \rangle \} \cup \{ \langle 1s \rangle \, | \, s \in \{0,1\}^{*} \}
```

# Encodings

For the purpose of this writeup, an **encoding** is an invertible mapping from $\mathbb{N}$ onto $\mathbb{B}$, and a **decoding** is the corresponding inverse. We will assume that encodings are rendered with the most significant bits leftmost. (We will formalize the notion of significant after giving some concrete examples of encodings and decodings.)

## Binary Encoding/Decoding

It is well known that a natural number can be represented as a sum over powers of 2. For example,

```math
13 = 2^3 + 2^2 + 2^0
```

The integer $n$ can equivalently be represented as a sum of all powers of 2 up to some $k$, each multiplied by a coefficient that is either 0 or 1:

```math
13 = (1 \cdot 2^3) + (1 \cdot 2^2) + (0 \cdot 2^1) + (1 \cdot 2^0)
```

Each possible sequence of coefficients — better known as bits — can be identified with a natural number. For example, the string $\langle 1110 \rangle$ corresponds to the natural number $13$ as shown above. Note that multiple distinct strings can correspond to the same natural number. For example, $\langle 01110 \rangle$ also corresponds to $15$; so does $\langle 001110 \rangle$. In order to guarantee invertibility, we require the binary string that is identified with a natural number be unique. This is achieved with a canonical binary string. 

Formally we define the **b**inary **enc**oding $benc: \mathbb{N} \rightarrow \mathbb{B}$ as the unique canonical binary string whose elements (bits) represent coefficients of the number with respect to powers of 2. We define $bdec: \mathbb{B} \rightarrow \mathbb{N}$ as the corresponding inverse, in other words the **b**inary **dec**oding that inverts $benc$. We assume this encoding is familiar to readers, so we do not explain it further.

## Stack Encoding/Decoding

The Peano axioms define the natural numbers according to a special element $0$ and the successor relation $S$. For example, $1$ is defined by a single application of the successor relation, 2 is defined by 2 applications, etc..:

| natural number | Peano string             | definition                                                |
|       :-:      |                      --: | :--                                                       |
|        0       | $\langle 0 \rangle$      | 0 is the least element                                    |
|        1       | $\langle S0 \rangle$     | 1 is the successor of 0                                   |
|        2       | $\langle SS0 \rangle$    | 2 is the successor of the successor of 0                  |
|        3       | $\langle SSSSS0 \rangle$ | 3 is the successor of the successor of the successor of 0 |
|       ...      | ...                      | ...                                                       |

This can be thought of as the "stack-of-plates" representation of a nonnegative integer — the integer $n$ is represented by $n$ applications of the successor function (plates), on top of the least element (base). 

The stack encoding is straightforward to define — just replace $S$ in the above with $1$. Note that while this mapping is 1-1, it does not cover the space of canonical binary strings. So it is not suitable for our purposes, at least not directly. Instead, we will combine stack encoding with another mapping to define an invertible mapping that does cover $\mathbb{B}$. In the next subsection, we cover this other mapping.

## Prime Factorization

Every positive integer can be represented as a product of primes. The representation is not quite unique, since the product can be expressed in multiple orders. For example,

```math
28 = 2 \cdot 2 \cdot 7 = 2 \cdot 7 \cdot 2
```

But, because integer multiplication is commutative, the order of factors does not matter. How many times each prime occurs in the product — its **multiplicity** — is sufficient to uniquely define the value. For $28$, the prime $2$ has multiplicity $2$ (occurs twice in the factorization), and the prime $7$ has multiplicity $1$ (and all other primes have multiplicity $0$). 

We define a canonical prime factorization by the multiplicities of every prime, with the primes written in ascending order; for example:

```math
28 = (2^2) \cdot (3^0) \cdot (5^0) \cdot (7^1) \cdot (11^0) \cdot (13^0) \ldots
```

Note that the primes are well-ordered. There is a least element ($2$), and for each prime $p_k$ there is a well-defined next prime $p_{k+1}$. Therefore, it is possible to represent a given integer by a vector of the multiplicities of the primes in its prime factorization; the $k^{\text{th}}$ value in the array represents the multiplicity of the $k^{\text{th}}$ prime. The multiplicity vector for $28$ is shown below:

```math
\begin{matrix}
           & p_1 = 2  & p_2 = 3 & p_3 = 5  & p_4 = 7 & p_5 = 11 & p_6 = 13 & \ldots & \\
    28 = ( &    2,    &    0,   &    0,    &    1,   &    0,   &     0,   & \ldots & )
\end{matrix}

Every such multiplicity vector $\hat{m}$ is eventually 0. That is, for every $\hat{m}$ there exists some $K$ such that $\hat{k} = 0$ for all $k > K$. Therefore, there is always a finite vector which can represent all of the nonzero multiplicities — one must include all multiplicities up to the last (greatest) prime whose multiplicity is nonzero; but none after that are needed. In the case of $28$, this finite multiplicity vector would be $(2,0,0,1)$.

The finite multiplicity vector representation of an integer is not an encoding, because it is a sequence of integers (rather than a sequence over the binary alphabet). However, it is possible to map the finite multiplicity vector representation of an integer into such a string. The next section formalizes the key idea, which is to define an encoding by composing two mappings. First, each integer is mapped to its finite multiplicity vector; next, the finite multiplicity vector is mapped to a canonical binary string by concatenating the stack encodings of each of the multiplicities.

# Definition

# Exploration

# Some Properties

# Final Thoughts

# Simple Permutations

A permutation is a 1-1 mapping from a set onto itself; in other words, an invertible rearrangement.

## Finite Permutations



## "Simple" Infinite Permutations

This section defines and gives examples of various "simple" families of permutations on the integers. In the final subsection we will share a conjecture as to what it means for a countably infinite permutation to be "simple".

### Identity but with finite exceptions

The finite permutation $P$ given earlier can be lifted into a corresponding permutation on the space of all integers by defining

```math
P^{\infty} = \begin{cases}
  P(n) & \text{ if } n \in Domain(P) \\
  n    & \text{ otherwise }
\end{cases}
```

In the essential ways, $P^{\infty}$ behaves the same as $P$. And the situation is the same for every infinite permutation that has a finite number of non-fixed points — its behavior is entirely captured by the corresponding finite permutation. Note that the identity permutation belongs to this family — the set of non-fixed points is empty!

### Infinite products of 1- and 2-cycles

Like finite permutations, infinite permutations can have cycles. Consider the following permutations on the set of (positive and negative) integers:

```math
\sigma(n) = \begin{cases}
  n + 1 & \text{ if n is even} \\
  n - 1 & \text{ if n is odd}
\end{cases}
```

This parity-flipping permutation can be represented as the infinite product of 2-cycles: $\sigma = \ldots (-2,-1) (0,1) (2,3) \ldots$. 

The sign-flipping permutation has one fixed point but otherwise consists of 2-cycles:

```math
\nu(n) = -n \\
\\
\nu = (0) (1,-1) (2,-2) \ldots
```

Up until now, all the permutations we have considered share the property that for some global $\Delta > 0$, $|P(n) - n| < \Delta$. The parity-flipping permutation $\nu$ is a counterexample: it is a very simple mapping with no upper bound to the distance between an element and its image under $\nu$. Finally, we note that the identity permutation belongs to this family — it can be represented by an infinite product of 1-cycles!

### Shift permutations

Unlike finite permutations, permutations on countably infinite sets do not have to produce any cycles at all. Consider the following shift-by-1 permutation:

```math
\rho_1(n) = n + 1
```

The orbit of every integer $k$ is the set $\{ k, k+1, \ldots \}$. There are no cycles; or put differently, there is 1 cycle of infinite length.

It is instructive to consider the shift permutation when the shift constant is larger than 1. For example, consider $\rho_6(n) = n + 6$. The orbit of $0$ is $\{0, 6, 12, \ldots \}$. The orbits of $1$, $2$, $3$, $4$, and $5% do not overlap with the orbit of $0$, nor with each other. But $6$ is different — the orbit of $6$ contains all the same values as the orbit of $0$, except for $0$ itself. Formally, we could say that (the orbit of) $6$ _eventually agrees_ with the orbit of $0$ (and with $-6$, and with $12$, etc..). In fact, we could partition the integers into 6 classes, depending on whether their orbit eventually agrees with the orbit of $0$, $1$, $2$, $3$, $4$, or $5$. If we agreed to call each element of that partition a cycle (of infinite length), then we could say that $\rho_6$ is represented by a finite product of 6 infinite cycles. (Readers familiar with finite groups will immediately note the connection with $\mathbb{Z}_6$).

We finally note that the identity permutation belongs to the class of shift permutations; it is simply that the shift constant is zero!

### A formal definition of "simple"?

The permutations given in this section are all "simple" in some sense. While we are not prepared to rigorously define "simple", we note that all of the examples given above fall into one of two classes:
* infinite product of finite cycles
* finite product of infinite cycles

Of course, a finite permutation is the finite product of finite cycles. This leaves a gap — a permutation which is the infinite product of infinite cycles. It is tempting to speculate that a "complex" permutation is exactly one which fills this gap. (This need not exclude finite cycles.)

# References
