# Natural Permutations

A permutation is a mapping which reorders elements of a set. The set can be finite, or infinite. There are many "simple" permutations on infinite sets — for example, the identity permutation simply maps an element to itself (no reordering). This writeup takes up the challenge of defining a non-simple permutation on the natural numbers. The approach is to define an encoding as an invertible mapping from the natural numbers onto a subspace of _canonical binary strings_. The permutation is defined by composing one encoding $benc$ with the inverse of a completely different one $penc$. This writeup includes exposition, as well as some limited exploration and analysis.

# Finite Permutations

A permutation $\pi : X \rightarrow X$ is a 1-1 mapping from a set onto itself. In other words, it is an invertible mapping whose image covers the domain.

Every finite permutation can be modeled as a permutation on the integers modulo n, $\mathbb{Z}_n = \{ 0, 1, \ldots, n-1 \}$. Here is an example on $\mathbb{Z}_6$:

```math
\pi = 
    \begin{pmatrix}
        0 & \rightarrow & 0 \\
        1 & \rightarrow & 2 \\
        2 & \rightarrow & 4 \\
        3 & \rightarrow & 5 \\
        4 & \rightarrow & 1 \\
        5 & \rightarrow & 3 \\
    \end{pmatrix}
```

Note that $\pi(0) = 0$, in other words $\pi$ maps $0$ to itself. This means that $0$ is a **fixed point** of $\pi$.

The **orbit** of an element is the sequence of elements that is generated by applying the permutation repeatedly, so that the output of one application becomes the input for the next. Let us examine the orbit of $3$ under $\pi$:

```math
\pi: 3 \rightarrow 5 \rightarrow 3 \rightarrow 5 \rightarrow \ldots
```

$\pi$ maps $3$ to $5$, and $5$ back to $3$. When the orbit of an element returns to the original element, it is called a cycle. This cycle can be efficiently represented with the cycle notation $(35)$; it is called a 2-cycle because the orbit passes through 2 elements before it repeats. 

In fact, fixed points are a special case of cycles — they are 1-cycles. Besides the 1-cycle $(0)$ and the 2-cycle $(35)$, $\pi$ also has a 3-cycle, $(124)$. Note that the number of elements in the domain of $\pi$, $| \mathbb{Z}_6 | = 6$, is the sum of the lengths of the cycles of $\pi$. It turns out that every finite permutation can be uniquely represented as the product of its cycles, which form a partition over the domain. For example, the cycle notation for $\pi$ is $(0)(124)(36)$.

The reasons this writeup has gone into such detail on the integers modulo n are
1. every finite permutation is isomorphic to a permutation on $\mathbb{Z}_n$ for some $n$
2. the notions of orbit, cycle, and partition are relevant for permutations on infinite sets

# Common

## Sets

We will use the following, countably infinite sets throughout the remainder of this writeup:

| name                     | symbol           | values                              |
| :--                      | :--              | :--                                 |
| natural numbers          | $\mathbb{N}$     | $\{ 0, 1 ,2, \ldots \}$             |
| integers                 | $\mathbb{Z}$     | $\{ \ldots, -1, 0, 1, 2, \ldots \}$ |
| positive natural numbers | $\mathbb{Z}^{+}$ | $\{1,2,\ldots\}$                    |

## Mappings

We will abuse notation slightly by referring to the following mappings, without regard to their domains.

| shift-by-k      | $\sigma_k(n)$ | $n \rightarrow n + k$ |
| multiply-by-k   | $\mu_k(n)$    | $n \rightarrow k \cdot n |
| parity-flipping | $\rho(n)$     | $n \rightarrow n + 1$ if n is even, else $n - 1$ |
| sign-flipping   | $\phi(n)$     | $n \rightarrow -n$ |

## Invertibility

The requirement of invertibility imposes strong constraints on whether a mapping constitutes a permutation. 

For example, the doubling function $\mu_2(n) = 2n$ cannot define a permutation on the integers, because the image does not cover the entire set. For example, the value $3$ does not have an inverse. The only values of $k$ for which $\mu_k$ defines a permutation on the integers are $k = 1$ (the identity mapping) and $k = -1$ (the sign-flipping map).

The "same" mapping might be a permutation or not, depending on its domain. Let us consider the shift-by-one mapping, $\sigma_1(n) = n + 1$. If the domain is the integers $\mathbb{Z}$, $\sigma_1$ is invertible — to obtain the inverse for any $n$, simply subtract 1 from it. However, when the domain is restricted to the natural numbers , it is not invertible. This is because the natural numbers have a least element, $0$. Subtraction from the least element is undefined; or put another way, $-1$ does not belong to $\mathbb{N}$. Even though the cardinality of $\mathbb{N}$ and $\mathbb{Z}$ is the same, the set of permutations on the natural numbers is much more restricted than for the integers as a whole.

## Simple Infinite Permutations

The parity-flipping and sign-flipping mappings define very simple permutations on the integers. In both cases, the permutation can be written as the product of (mostly) 2-cycles:

```math
\rho = \ldots (-2,-1) (0,1) (2,3) \ldots
\phi = (0) (1,-1) (2,-2) \ldots
```

Unlike finite permutations, it is not guaranteed that infinite permutations can be expressed as the product of cycles — at least, not without modifying our understanding of cycle. If we consider the shift-by-one permutation, the orbit of an element does not repeat. The orbit of every integer $k$ is the set $\{ k, k+1, \ldots \}$. There are no cycles; or put differently, there is 1 cycle of infinite length.

It is instructive to consider the shift permutation when the shift constant is larger than 1. For example, consider $\rho_6(n) = n + 6$. The orbit of $0$ is $\{0, 6, 12, \ldots \}$. The orbits of $1$, $2$, $3$, $4$, and $5% do not overlap with the orbit of $0$, nor with each other. But $6$ is different — the orbit of $6$ contains all the same values as the orbit of $0$, except for $0$ itself. Formally, we could say that (the orbit of) $6$ _eventually agrees_ with the orbit of $0$ (and with $-6$, and with $12$, etc..). In fact, we could partition the integers into 6 classes, depending on whether their orbit eventually agrees with the orbit of $0$, $1$, $2$, $3$, $4$, or $5$. If we agreed to call each element of that partition a cycle (of infinite length), then we could say that $\rho_6$ is represented by a finite product of 6 infinite cycles. (In fact, this is roughly how $\mathbb{Z}_6$ is constructed from the integers.)

A final class of simple infinite permutations consists of mappings which map an element to itself for all but a finite number of elements. For a given finite permutation $\pi$, it is straightforward to "lift" it to a corresponding permutation on an infinite set, like so:

```math
\pi^{\infty} = \begin{cases}
  \pi(n) & \text{ if } n \in Domain(\pi) \\
  n    & \text{ otherwise }
\end{cases}
```

By construction, this lifted mapping is the identity function everywhere except on the domain of $\pi$. In most interesting ways, these two permutations behave the same. The cycles of $ \pi^{\infty} $ are the cycles of $\pi$, plus fixed points for every other element which is not in the domain of $\pi$. The nontrivial mappings of $\pi$ and $ \pi^{\infty} $ are the same. So every infinite permutation in this class can be identified by the corresponding finite permutation.

# Encoding

The strategy is to define an encoding as an invertible mapping from the natural numbers to a space of **canonical binary strings**. (A decoding is defined as the inverse.) By creating two unrelated mappings, `benc`/`bdec` and `penc`/`pdec`, we define a permutation on the natural numbers by composing one encoder with the non-matching decoder.

## Canonical Binary Strings

Let the binary alphabet be $ \Sigma = \{ 0,1 \} $. Further, let $\Sigma^{*}$ be the set of finite strings over this alphabet. A string $s \in \Sigma^*$ is in canonical form if any of the following conditions hold:
* $s = \langle 0 \rangle$
* the initial/leftmost/most significant bit of $s$ is a $1$

Notation: We enclose strings with angle brackets, but not individual characters of the alphabet. An example of a non-canonical string is $\langle 0101 \rangle$. It is non-canonical because the initial bit is $0$. In general, a canonical binary string can be obtained from a non-canonical one by stripping all leading $0$'s. The canonical binary string that corresponds to $\langle 0101 \rangle$ is $\langle 101 \rangle$. The sole exception is when the string contains no $1$'s; in that case, a single leading $0$ is allowed (to distinguish $\langle 0 \rangle$ from an empty string). Formally, we define canonical binary strings as the subset of $\Sigma^{*}$ which is in canonical form:

```math
\mathbb{B} = \{ \langle 0 \rangle \} \cup \{ \langle 1s \rangle \, | \, s \in \{0,1\}^{*} \}
```

# Encodings

For the purpose of this writeup, an **encoding** is an invertible mapping from $\mathbb{N}$ onto $\mathbb{B}$, and a **decoding** is the corresponding inverse. To be crystal clear about this, we use the term "onto" in the technical sense that the image of $\mathbb{N}$ must cover $\mathbb{B}$. In other words, a mapping $xenc$ can only be an encoding if for every canonical binary string $b$, there exists some natural number $n$ such that $xenc(n) = b$. This writeup will render strings left-to-right, with the most significant bits leftmost. (We will explain the notion of significant bits more after giving some concrete examples of encodings and decodings.)

## Binary Encoding/Decoding

It is well known that a natural number can be represented as a sum over powers of 2. For example,

```math
13 = 2^3 + 2^2 + 2^0
```

The integer $n$ can equivalently be represented as a sum of all powers of 2 up to some $k$, each multiplied by a coefficient that is either 0 or 1:

```math
13 = (1 \cdot 2^3) + (1 \cdot 2^2) + (0 \cdot 2^1) + (1 \cdot 2^0)
```

The general idea behind the **b**inary **enc**oding ($benc$) is to identify the integer (e.g. $13$) with the sequence of coefficients (aka bits). The corresponding binary decoder simply maps the digit sequence back into an integer. This is a highly familiar mapping, familiar to most programmers and mathematicians alike.

There is just one technical matter to attend to. Under standard implementations, the binary encoding/decoding is not unique. For example, the string $\langle 1110 \rangle$ corresponds to the natural number $13$ as shown above — but so do $\langle 01110 \rangle$ and $\langle 001110 \rangle$. Things will go more smoothly if we can guarantee invertibility. And this is very simple to achieve by requiring the encoding to map onto $\mathbb{B}$, rather than into $\Sigma^{*}$. Put another way, the restriction to canonical binary strings is a convenience that makes it easier to guarantee invertibility.

## Stack Encoding/Decoding

The Peano axioms define the natural numbers according to a special element $0$ and the successor relation $S$. For example, $1$ is defined by a single application of the successor relation, 2 is defined by 2 applications, etc..:

| natural number | Peano string             | definition                                                |
|       :-:      |                      --: | :--                                                       |
|        0       | $\langle 0 \rangle$      | 0 is the least element                                    |
|        1       | $\langle S0 \rangle$     | 1 is the successor of 0                                   |
|        2       | $\langle SS0 \rangle$    | 2 is the successor of the successor of 0                  |
|        3       | $\langle SSSSS0 \rangle$ | 3 is the successor of the successor of the successor of 0 |
|       ...      | ...                      | ...                                                       |

This can be thought of as the "stack-of-plates" representation of a nonnegative integer — the integer $n$ is represented by $n$ applications of the successor function (plates), on top of the least element (base). 

The stack encoding is straightforward to define — just replace $S$ in the above with $1$. Note that while this mapping is 1-1, it does not cover the space of canonical binary strings. So it is not suitable for our purposes, at least not directly. Instead, we will combine stack encoding with another mapping to define an invertible mapping that does cover $\mathbb{B}$. In the next subsection, we cover this other mapping.

## Prime Factorization

Every positive integer can be represented as a product of primes. The representation is not quite unique, since the product can be expressed in multiple orders. For example,

```math
28 = 2 \cdot 2 \cdot 7 = 2 \cdot 7 \cdot 2
```

But, because integer multiplication is commutative, the order of factors does not matter. How many times each prime occurs in the product — its **multiplicity** — is sufficient to uniquely define the value. For $28$, the prime $2$ has multiplicity $2$ (occurs twice in the factorization), and the prime $7$ has multiplicity $1$ (and all other primes have multiplicity $0$).

We define a canonical prime factorization as follows. Let $\vec{p} = (2, 3, 5, \ldots)$ be the sequence of primes in ascending order. We define a **multiplicity vector** $\vec{m}$ as a sequence of nonnegative integers which is eventually $0$ — in other words there exists some $K$ such that $m_k = 0$ for all $k > K$. There is a natural mapping from multiplicity vectors to integers representing the prime decomposition:

```math
n = \Pi_{k=1}^\infty (p_k)^{m_k}
```

For example,

```math
\begin{matrix}
                    & p_0 = 2  & p_1 = 3 & p_2 = 5  & p_3 = 7 & p_4 = 11 & p_5 = 13 & \ldots & \\
    \vec{m}(28) = ( &    2,    &    0,   &    0,    &    1,   &    0,   &     0,   & \ldots & )
\end{matrix}

The multiplicity vector representation of a positive integer is unique, because
* every positive integer can be uniquely expressed as the product of a multiset of primes, and
* the multiplicity vector corresponds invertibly to a multiset

Now, the multiplicity vector an integer is not an encoding, because it maps to a sequence of counts (nonnegative integers) rather than a sequence of bits. However, in the last section, we saw that the stack encoding gives a way to map every count to a sequence of bits. The next section formalizes the key idea, which is to define an encoding by combining two mappings. First, each integer is mapped to its finite multiplicity vector; next, the finite multiplicity vector is mapped to a canonical binary string by concatenating the stack encodings of each of the multiplicities.

# Definition

# Exploration

# Some Properties



### A formal definition of "simple"?

The permutations given in this section are all "simple" in some sense. While we are not prepared to rigorously define "simple", we note that all of the examples given above fall into one of two classes:
* infinite product of finite cycles
* finite product of infinite cycles

Of course, a finite permutation is the finite product of finite cycles. This leaves a gap — a permutation which is the infinite product of infinite cycles. It is tempting to speculate that a "complex" permutation is exactly one which fills this gap. (This need not exclude finite cycles.)

# References
