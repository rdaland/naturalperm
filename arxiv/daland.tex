\documentclass[12pt,reqno]{article}

\usepackage[usenames]{color}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amscd}
\usepackage{graphicx}
\usepackage{mathrsfs}

\usepackage[colorlinks=true,
linkcolor=webgreen,
filecolor=webbrown,
citecolor=webgreen]{hyperref}

\definecolor{webgreen}{rgb}{0,.5,0}
\definecolor{webbrown}{rgb}{.6,0,0}

\usepackage{color}
\usepackage{fullpage}
\usepackage{float}

\usepackage{graphics}
\usepackage{latexsym}
\usepackage{epsf}
\usepackage{breakurl}

\setlength{\textwidth}{6.5in}
\setlength{\oddsidemargin}{.1in}
\setlength{\evensidemargin}{.1in}
\setlength{\topmargin}{-.1in}
\setlength{\textheight}{8.4in}

\newcommand{\seqnum}[1]{\href{https://oeis.org/#1}{\rm \underline{#1}}}

\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\xenc}{\mathrm{xenc}}
\let\up=\textsuperscript
\newcommand{\ct}{c}
\usepackage{bigints}
\def\restmod#1#2{#1\ (\mathrm{mod}\ #2)} %%% for the congruences


\begin{document}

\begin{center}
\epsfxsize=4in
\end{center}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}
\newtheorem{conjecture}[theorem]{Conjecture}

\theoremstyle{remark}
\newtheorem{remark}[theorem]{Remark}

\begin{center}
\vskip 1cm{\Large\bf A Partial Typology of Permutations on the Natural Numbers
}
\vskip 1cm
\large
Robert Daland \\
Siri Natural Language Understanding \\
Apple, Inc \\
\href{mailto:r.daland@gmail.com}{\tt r.daland@gmail.com} 
\end{center}

\vskip .2 in

\begin{abstract}
Permutations on the natural numbers are theoretically uncountable. Yet, despite their theoretical fecundity, concrete examples are somewhat rare in the literature. This paper opens by describing an incomplete typology of generator patterns for ``simple'' examples. It conjectures that ``simple'' natural permutations are defined by a locality property, namely that the maximum displacement $|\pi(n) - n|$ is upper-bounded by $C|n|$ for some $C$. A ``nonsimple'' permutation is introduced which seemingly lacks this property. \end{abstract}

\section{Introduction}

What can a permutation on the natural numbers look like? And what constraints does the structure of the natural numbers impose on the space of permutations of this countably infinite set?

\section{Notation and conventions}

For this article, sometimes it matters whether the natural numbers begin at 0 or 1, and sometimes it does not. This article will default to $\mathbb{N}$ beginning at 1; when it is important to distinguish, the notation $\mathbb{N}_0$ will be used to explicitly indicate starting from 0: \begin{itemize} 
  \item $\mathbb{N} = \{ 1, 2, \ldots \}$
  \item $\mathbb{N}_0 = \{ 0, 1, \ldots \}$
\end{itemize}

The term \textbf{orbit} will refer to the collection of values generated by repeated application of a map, starting from some reference value. The term \textbf{cycle} will be reserved for orbits in which the same value repeats after finitely many iterations of the map, i.e. $\pi^k(n) = n$ for some positive $k$. Orbits may include preimages of the reference value, i.e. a sequence of values may extend ``backwards'' when that is well-defined. 

The term \textbf{natperm} will be used to refer a permutation on the natural numbers; that is, an invertible map $\pi: \mathbb{N} \rightarrow \mathbb{N}$. The \textbf{support} of a natperm is the set of values which are not fixed points; in other words the subset of the natural numbers for which the natperm is not the identity mapping. 

\section{Block cyclic natperms}

This section will define and illustrate natperms of increasing complexity. Prior to discussing specific natperms, it is worth highlighting that natperms are closed under finite composition. That is, if $\pi$ and $\sigma$ are natperms, so is $\pi \circ \sigma(n) = \pi(\sigma(n))$ and $\sigma \circ \pi(n)$ (note that composition is not generally commutative). This article does not treat infinite composition in the general case; however it is worth pointing out that a number of cases discussed here can also be understood as infinite compositions of disjoint natperms.

\subsection{Finite natperms}

It is trivial to lift a finite permutation (on positive integers) to a natperm. For example, the permutation $\xi = (1 \ 2)$ can be extended by applying the identity map to all natural numbers not in the original domain, $\tilde{\xi} = (1 \ 2)(3)(4)\cdots$. Such mappings will be called \textbf{finite natperms} (i.e. a permutation on the natural numbers, but with finite support).

\subsection{Bounded block cyclic natperms}

Consider the parity-swapping map:
\begin{equation}
    \pi(n) = \begin{cases}
        n + 1, & \text{if n is odd} \\
        n - 1, & \text{if n is even}
    \end{cases}
\end{equation}

This mapping is a natperm, whose behavior can be illustrated with the cycle notation $\pi = (1 \ 2)(3 \ 4)(5 \ 6)\cdots$. The definition given above makes it particularly clear that this mapping covers the natural numbers.

An alternative and more general way to view the parity-swapping natperm is as the infinite product of finite natperms on disjoint blocks. Formally, define a \textbf{block partition} of the natural numbers by an infinite sequence of cutoffs $({b_j})_{j=1}^{\infty}$. The first block is defined $B_1 = \{ 1 \leq n < b_1 \; | \; n \in \mathbb{N} \}$, in other words the contiguous block of natural numbers less than the first cutoff. Remaining blocks are defined analogously,  $B_j = \{ b_{j-1} \leq n < b_j \}$. A block partition is bounded if there is a maximum block size, i.e. $\exists M \ni |b_j - b_{j-1}| < M$. A mapping is a bounded block cyclic natperm it if can be represented by a sequence of cycles on blocks, generated by a bounded block partition. For the parity-swapping map defined above, the block partition is defined by the cutoffs $\bar{b} = \{ 3, 5, 7, \ldots \}$, and the individual blocks simply have the shift-by-1 map, gluing the top of each block to its bottom. 

It is easy to imagine variants of block cyclic natperms -- larger block sizes, block permutations other than the shift-by-1 map. A notable property of bounded block cyclic natperms is that the mapping is essentially ``local'' -- every value $n$ is mapped to some other value near $n$. More specifically, for all n $|\pi(n) - n| \leq M$ for some $M$, where $M$ is the partition block bound. Another variation would include a finite number of noncontiguous blocks. Since each noncontiguous block can be mapped to a contiguous block with a finite mapping $B$, such a mapping $\rho$ could be represented as a product of block mappings $\rho = B_k^{-1} B_{k-1}^{-1} \cdots B_1^{-1} \pi B_1 B_2 \cdots B_k$ where $\pi$ is a bounded block cyclic mapping (proof/counterexample is left to future reseach).

Bounded block cyclic natperms are a special case of unbounded block cyclic natperms, which are defined and illustrated next.

\subsection{Unbounded block cyclic natperms}

The definition of block partition requires a countably infinite number of finite blocks, but does not impose a cutoff on block size. Here is an example which cannot be represented by finite blocks:
\begin{equation}
    \pi(n) = \begin{cases}
        1, & \text{if } n = 1 \\
        2^{k-1} + 1, & \text{if } n = 2^k \ \text{for some positive integer}\ k \\
        n + 1, & \text{otherwise}
    \end{cases}
\end{equation}

This mapping is a natperm. It can be decomposed into an infinite product of finite cycles, whose length grows geometrically. The first several cycles are shown below:
$$ (1)(2)(3 \ 4)(5 \ 6 \ 7 \ 8)\cdots $$ 
% TODO: put block 2^0, 2^1, ... annotations in
This mapping partitions the natural numbers into \textbf{blocks}, with a finite permutation defined on each block. The blocks are the set of natural numbers ranging from $2^{k-1} + 1$ to $2^k$, and the finite permutation is simply the shift map, but gluing the top of the block to its bottom to define a simple cycle.

The key difference between this natperm and the parity-swapping one is the nature of the ``locality'' condition. Values are still always mapped within their block; but because the block size is unbounded, the displacement is unbounded too. Note however that even though the blocks grow exponentially, the maximum displacement grows linearly with block size. As a result, the maximum displacement scales linearly with $n$: there exists a $C$ such that $|\pi(n) - n| \leq C |n|$ for all $n$. This property will be referred to as \textbf{local displacement}.

\section{Shift-and-glue natperms}

Observe that there are many functions which do define permutations on the integers, but which do not define permutations on the natural numbers. The simplest example is the shift-by-1 function $\sigma_1(n) = n + 1$, which can be decomposed into a single, countably infinite orbit:
$$ \cdots \rightarrow -2 \rightarrow -1 \rightarrow 0 \rightarrow 1 \rightarrow \cdots $$
However, when the domain is restricted to natural numbers, there is a least element, which has no preimage. Therefore the mapping is not invertible, and cannot be a permutation.

A related example is the shift-by-k function $\sigma_k(n) = n + k$. This permutation on the integers can be decomposed into $k$ distinct countably infinite orbits. However, just as with the shift-by-1 function, restricting the domain to the natural numbers eliminates invertibility, again because each orbit has a least element. This paper will use the term \textbf{strand} to the set of natural numbers in a single orbit of a shift-by-k function. It is convenient to refer to the strand by its least element. For example, ${\lfloor 1 \rfloor}_k$ denotes the strand $\{ 1, 1 + k, 1 + 2k, \ldots \}$ generated by $\sigma_k(n)$. (Remark: $\sigma_{-k}(n)$ generates the same strands as $\sigma_k(n)$.)

It is possible to generate a permutation on the natural numbers by gluing together the two strands of $\sigma_2$. This is achieved by traversing one strand in descending order, switching over at the least elements, and then traversing the remaining strand in ascending order. For example, the permutation ($\ldots$, 6, 4, 2, 1, 3, 5, $\ldots$) is achieved with this mapping:
\begin{equation}
    \pi(n) = \begin{cases}
        \sigma_{-2}(n), & \text{if}\ n \text{ is even and greater than 2} \\
        1, & \text{if}\ n = 2 \\
        \sigma_2(n), & \text{if}\ n \text{ is odd} 
    \end{cases}
\end{equation}

The following shorthand is sufficient to represent the natperm, if we adopt some notational conventions:
\begin{equation}
  \pi = {(\lfloor 2 \rfloor \rightarrow \lfloor 1 \rfloor)}_2
\end{equation}
The primary notational convention is that if a strand occurs on the left-hand side of $\rightarrow$, it is a \textbf{tail strand}, in other words traversal is in descending order, while if the strand occurs on the right-hand side of $\rightarrow$, it is a \textbf{head strand}, in other words traversal is in ascending order. A second convention is to indicate the shift value $2k$ at the end, rather than on each least element, since the notation is only well-defined when all strands are generated by the same shift map. Note that this convention forbids a representation like ${(\lfloor 1 \rfloor \rightarrow \lfloor 2 \rfloor \rightarrow \lfloor 3 \rfloor)}_3$, where the same strand ${\lfloor 2 \rfloor}_3$ appears as both the left-hand and right-hand side of $\rightarrow$. It is forbidden because this implies traversal in both ascending and descending orders at the same time, a contradiction.

The same approach can be applied to permutations with any even number of strands. The shift permutation $\sigma_{2k}$ generates strands $\{ \lfloor 1 \rfloor,  \lfloor 2 \rfloor, \ldots, \lfloor 2k \rfloor \}_{2k}$. These are paired off, glued at their least elements, and assigned a direction (i.e. which strand to traverse by counting down, and which to traverse by counting up), resulting in $k$ orbits. The permutation $\pi = {( \lfloor 1 \rfloor \rightarrow \lfloor 5 \rfloor, \ \lfloor 2 \rfloor \rightarrow \lfloor 3 \rfloor, \ \lfloor 6 \rfloor \rightarrow \lfloor 4 \rfloor )}_{2k}$ is shown in Figure 1. % TODO labels

% TODO: put an image here with N_k arranged in a circle as usual, and with strands emanating from N_k with the gluing indicated

Note that such shift-and-glue natperms exhibit local displacement. For basic shift-and-glue natperms, it is easy to verify that the maximum displacement is simply the magnitude of the shift from the shift function. However, the maximum displacement may be larger under composition. For example, "strand switching" is achieved by composing a shift-and-glue natperm with a lifted 2-cycle. An example with $(17 \ 18) \circ \pi$ is shown in Figure 2.

% TODO: do the same shift-and-glue natperm as Fig. 1, but with a 2-cycle that transposes some elements above the least elements

As a matter of convenience, the shift-and-glue notation can be extended so that elements which are not explicitly included in a representation are subject to the identity mapping. Thus, while  ${( \lfloor 1 \rfloor \rightarrow \lfloor 2 \rfloor \rightarrow \lfloor 3 \rfloor)}_3$ is excluded, the mapping ${( \lfloor 1 \rfloor \rightarrow 2 \rightarrow \lfloor 3 \rfloor )}_3$ is well-defined. The latter simply means that all elements in the strand ${\lfloor 2 \rfloor}_3$ map to themselves, \textit{except for the least element 2 itself}. Finally, as with all natperms, shift-and-glue natperms can be composed with any other natperms, including bounded block cyclic natperms. (However, this article will not visualize the structure of such compositional examples.)

\section{A natperm with nonlocal displacement}

The previous sections have introduced a partial typology of generator patterns for generating natperms. These all follow the general pattern of partitioning the integers into blocks or strands, and traversing the elements via a shift function with some glueing at the ends. And as a result, they all satisfy a locality condition. Formally, a natperm has \textbf{local displacement} if and only if $\exists C [\forall n [|\pi(n) - n| \leq C|n|]]$. Intuitively, it seems likely that there are natperms which exhibit nonlocal displacement. But how to construct one? This section shows how to construct a natperm which appears to exhibit nonlocal displacement.

\subsection{Overview and notation}

When two sets $X$ and $Y$ are isomorphic, it is understood that they have the same structure -- either set can represent the other. An isomorphism consists of a bijection $f : X \rightarrow Y$. This article will refer to $f$ as an \textbf{encoder}, and $f^{-1}$ as the corresponding \textbf{decoder}. From the perspective of set comparison, the specific function $f$ is not of much interest, except insofar as it can be verified to exist and be 1-1 and onto (in other words an isomorphism).

However, suppose that two distinct bijections $f$ and $g$ exist. The image of $X$ under $f$ is the entire set $Y$ (because $f$ is onto), and the preimage of $Y$ under $g$ is the entire set $X$ (because $g$ is 1-1). In other words, $(g^{-1} \circ f) (X) = X$, so the function $(g^{-1} \circ f)$ is a bijection of $X$ onto itself. Crucially, since $f$ and $g$ are different mappings, $(g^{-1} \circ f)$ is not the identity mapping (at least not for every element). Then, if $X$ is the natural numbers $\mathbb{N}$, the mapping $(g^{-1} \circ f)$ is a natperm.

The basic idea is to identify a space $\mathbb{B}$ that is isomorphic to $\mathbb{N}$ and to identify two different encoder-decoder pairs. From this it is straightforward to define a natperm by composing one encoder with the other decoder. For this article, the other space is the set of \textbf{canonical binary strings}
\begin{equation}
  \mathbb{B} = \{ \langle 0 \rangle \} \cup \{ \langle 1s \rangle \, | \, s \in \{0,1\}^{*} \}
\end{equation}
where $*$ is the Kleene star operator, meaning any number of repetitions of any elements. For clarity, strings will be delimited by angle brackets; thus $\langle \rangle$ denotes the empty string (which is not a canonical binary string), while $\langle 0 \rangle$ denotes the string consisting only of the symbol $0$. Note that $\langle 0 \rangle$ is the only canonical binary string which does not begin with the symbol $1$.

\end{document}

